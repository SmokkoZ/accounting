# Story 8.9: Performance Hardening - Caching, Pagination, Thumbnails, DB Indexes

## Status
Draft

## Story
**As a** system operator, **I want** fast tables and light images, **so that** daily operations feel instant.

## Acceptance Criteria

1. Centralized caching (`src/ui/cache.py`): `@st.cache_resource` for DB, `@st.cache_data(ttl=5)` wrapper `query_df(sql, params=())`
2. Pagination (25/50/100): `LIMIT/OFFSET`, total count, per-table session state
3. Thumbnails (`src/ui/media.py`): `make_thumb(path, w=300)`; list views show thumbs, full images on demand
4. Form-gated filters in incoming/verified/reconciliation pages
5. Rerun guardrails: `safe_rerun(reason)` helper; remove ad-hoc reruns in render loops
6. Remove `sleep` and noisy logs from hot paths (flagged if needed)
7. SQLite indexes migration: `idx_bets_status_created`, `idx_surebets_status_created`, `idx_ledger_surebet`, `idx_ledger_created`; verify with `EXPLAIN`
8. Perf dashboard: Admin â†’ Advanced shows last 50 timings; "UI Performance Playbook" docs
9. Benchmarks (non-blocking): 10k bets â†’ filter apply to first paint â‰¤ 1.5s; expanders/popovers feel instant

## Tasks / Subtasks

- [ ] Task 1: Create centralized caching system (AC: 1)
  - [ ] Create `src/ui/cache.py` with `@st.cache_resource` for DB connections
  - [ ] Create `@st.cache_data(ttl=5)` wrapper for query results
  - [ ] Implement `query_df(sql, params=())` function for cached DataFrame queries
  - [ ] Add cache invalidation helpers for write operations
  - [ ] Add unit tests for caching functionality

- [ ] Task 2: Implement pagination system (AC: 2)
  - [ ] Create pagination helper functions in `src/ui/utils/pagination.py`
  - [ ] Implement `LIMIT/OFFSET` SQL generation with parameterized queries
  - [ ] Add total count queries with caching
  - [ ] Create pagination UI components (25/50/100 options, next/prev)
  - [ ] Add per-table session state management for pagination
  - [ ] Integrate pagination into all major tables (incoming bets, surebets, ledger, etc.)
  - [ ] Add unit tests for pagination logic

- [ ] Task 3: Create thumbnail system for images (AC: 3)
  - [ ] Create `src/ui/media.py` with `make_thumb(path, w=300)` function
  - [ ] Implement thumbnail generation with PIL and caching
  - [ ] Update list views to show thumbnails instead of full images
  - [ ] Add click-to-expand functionality for full image viewing
  - [ ] Implement thumbnail cache management
  - [ ] Add unit tests for thumbnail generation and display

- [ ] Task 4: Implement form-gated filters (AC: 4)
  - [ ] Update incoming bets page filters to use `st.form`
  - [ ] Update verified bets page filters to use `st.form`
  - [ ] Update reconciliation page filters to use `st.form`
  - [ ] Ensure filter changes don't trigger immediate reruns
  - [ ] Add clear filters functionality
  - [ ] Test form-gated filters prevent mid-typing reruns

- [ ] Task 5: Create rerun guardrails system (AC: 5)
  - [ ] Implement `safe_rerun(reason)` helper in `src/ui/utils/state_management.py`
  - [ ] Add debug logging for rerun reasons
  - [ ] Remove ad-hoc `st.rerun()` calls from render loops
  - [ ] Replace with safe rerun patterns where needed
  - [ ] Add unit tests for rerun guardrails

- [ ] Task 6: Optimize hot paths (AC: 6)
  - [ ] Audit code for `sleep` calls in hot paths
  - [ ] Remove or optimize unnecessary sleep calls
  - [ ] Audit for noisy debug logs in performance-critical sections
  - [ ] Implement conditional logging based on debug flags
  - [ ] Add performance monitoring for hot path identification

- [ ] Task 7: Create and apply database indexes (AC: 7)
  - [ ] Create migration script for performance indexes
  - [ ] Add `idx_bets_status_created` index
  - [ ] Add `idx_surebets_status_created` index
  - [ ] Add `idx_ledger_surebet` index
  - [ ] Add `idx_ledger_created` index
  - [ ] Verify index usage with `EXPLAIN` queries
  - [ ] Add unit tests for index migration

- [ ] Task 8: Create performance dashboard (AC: 8)
  - [ ] Add performance timing collection to UI pages
  - [ ] Create perf dashboard in Admin â†’ Advanced section
  - [ ] Show last 50 page load timings with breakdowns
  - [ ] Create "UI Performance Playbook" documentation
  - [ ] Add performance monitoring helpers
  - [ ] Add integration tests for performance dashboard

- [ ] Task 9: Implement performance benchmarks (AC: 9)
  - [ ] Create benchmark test suite for 10k bet dataset
  - [ ] Implement filter performance measurement (â‰¤ 1.5s target)
  - [ ] Test expander/popover responsiveness
  - [ ] Add performance regression tests
  - [ ] Document benchmark results and targets
  - [ ] Create performance monitoring alerts

## Dev Notes

### Previous Story Insights
From Story 8.8 (UX Enhancements & Workflow Improvements):
- Form-gated filter patterns established with `form_gated_filters()` function [Source: docs/stories/8.8.ux-enhancements-workflow-improvements.md#Dev Notes]
- Advanced controls pattern with expanders implemented across pages
- State management helpers available in `src/ui/utils/state_management.py`
- Timezone formatters and UI components established

From Story 8.7 (Feature Flags & Version Compatibility):
- Feature flag utility available for conditional feature implementation [Source: docs/stories/8.7.feature-flags-version-compatibility.md#Dev Notes]
- Version detection patterns established for graceful degradation
- Admin panel structure available for adding performance dashboard

From Story 8.6 (Streaming & Progress Indicators):
- Performance monitoring patterns established with status blocks [Source: docs/stories/8.6.streaming-progress-indicators.md#Dev Notes]
- Progress feedback patterns available for long-running operations
- Toast notification patterns for performance feedback

From Story 8.4 (Performance - Fragments & Partial Reruns):
- Fragment implementation provides foundation for performance optimization [Source: docs/stories/8.4.performance-fragments-partial-reruns.md#Dev Notes]
- Performance timer logging patterns available
- Rerun control mechanisms established

### Performance Architecture Requirements

**Centralized Caching System** [Source: docs/architecture/frontend-architecture.md#Performance & Reliability]:
```python
# src/ui/cache.py
import streamlit as st
import pandas as pd
from typing import Any, Tuple, Optional
from src.core.database import get_db_connection

@st.cache_resource
def get_db_connection_cached():
    """Cached database connection for the session"""
    return get_db_connection()

@st.cache_data(ttl=300)  # 5 minutes TTL
def query_df(sql: str, params: Tuple = ()) -> pd.DataFrame:
    """Execute query and return cached DataFrame"""
    conn = get_db_connection_cached()
    return pd.read_sql_query(sql, conn, params=params)

def invalidate_cache(key_pattern: str = None):
    """Invalidate cache entries matching pattern"""
    if hasattr(st.cache_data, 'clear'):
        st.cache_data.clear()
```

**Pagination Implementation** [Source: docs/architecture/frontend-architecture.md#Performance & Reliability]:
```python
# src/ui/utils/pagination.py
import streamlit as st
from typing import Tuple, Dict, Any

def paginate_data(
    total_count: int,
    page_size: int = 25,
    page_key: str = "page"
) -> Tuple[int, int, Dict[str, Any]]:
    """Generate pagination controls and return offset/limit"""
    if page_key not in st.session_state:
        st.session_state[page_key] = 1
    
    current_page = st.session_state[page_key]
    total_pages = (total_count + page_size - 1) // page_size
    
    # Pagination UI
    col1, col2, col3, col4, col5 = st.columns([1, 1, 2, 1, 1])
    
    with col1:
        if st.button("â† Prev", disabled=current_page == 1):
            st.session_state[page_key] = max(1, current_page - 1)
            st.rerun()
    
    with col2:
        st.selectbox(
            "Rows per page",
            options=[25, 50, 100],
            index=[25, 50, 100].index(page_size),
            key=f"{page_key}_size",
            on_change=lambda: setattr(st.session_state, page_key, 1)
        )
    
    with col3:
        st.write(f"Page {current_page} of {total_pages} ({total_count} total)")
    
    with col4:
        if st.button("Next â†’", disabled=current_page == total_pages):
            st.session_state[page_key] = min(total_pages, current_page + 1)
            st.rerun()
    
    with col5:
        st.number_input(
            "Go to page",
            min_value=1,
            max_value=total_pages,
            value=current_page,
            key=f"{page_key}_goto",
            on_change=lambda: st.rerun()
        )
    
    offset = (current_page - 1) * page_size
    return offset, page_size, {"current_page": current_page, "total_pages": total_pages}
```

**Thumbnail System** [Source: docs/architecture/frontend-architecture.md#Performance & Reliability]:
```python
# src/ui/media.py
import streamlit as st
from PIL import Image
import io
import os
from pathlib import Path
from typing import Optional

@st.cache_data(ttl=3600)  # 1 hour cache for thumbnails
def make_thumb(image_path: str, width: int = 300) -> Optional[str]:
    """Generate thumbnail for image, return path or base64"""
    try:
        if not os.path.exists(image_path):
            return None
        
        # Generate thumbnail
        img = Image.open(image_path)
        
        # Calculate height maintaining aspect ratio
        aspect_ratio = img.height / img.width
        height = int(width * aspect_ratio)
        
        # Resize and save thumbnail
        img.thumbnail((width, height), Image.Resampling.LANCZOS)
        
        # Convert to base64 for inline display
        buffer = io.BytesIO()
        img.save(buffer, format="PNG", optimize=True)
        img_str = buffer.getvalue()
        
        return img_str
    
    except Exception as e:
        st.error(f"Error generating thumbnail: {e}")
        return None

def display_thumbnail_or_full(image_path: str, caption: str = "", width: int = 300):
    """Display thumbnail with click to expand functionality"""
    thumb_data = make_thumb(image_path, width)
    
    if thumb_data:
        if st.image(thumb_data, caption=caption, width=width, use_container_width=False):
            # Click on image to show full size
            st.session_state[f"show_full_{image_path}"] = True
    
    # Show full image if requested
    if st.session_state.get(f"show_full_{image_path}"):
        if st.button("Close Full Size", key=f"close_{image_path}"):
            st.session_state[f"show_full_{image_path}"] = False
            st.rerun()
        
        st.image(image_path, caption=f"Full Size: {caption}", use_container_width=True)
```

**Rerun Guardrails** [Source: docs/architecture/frontend-architecture.md#Performance & Reliability]:
```python
# src/ui/utils/state_management.py (enhanced)
import streamlit as st
import time
from typing import Optional

def safe_rerun(reason: str = "User action", max_frequency: float = 0.5):
    """Safe rerun with frequency limiting and debug logging"""
    current_time = time.time()
    last_rerun = st.session_state.get("last_rerun_time", 0)
    
    if current_time - last_rerun < max_frequency:
        st.warning(f"Too many rapid actions. Please wait a moment.")
        return False
    
    # Debug logging
    if st.session_state.get("debug_mode", False):
        st.sidebar.write(f"ðŸ”„ Rerun: {reason} at {time.ctime(current_time)}")
    
    st.session_state["last_rerun_time"] = current_time
    
    if hasattr(st, 'rerun'):
        st.rerun()
    return True

def with_performance_monitoring(func):
    """Decorator to monitor function performance"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        # Store timing data
        if "performance_timings" not in st.session_state:
            st.session_state["performance_timings"] = []
        
        st.session_state["performance_timings"].append({
            "function": func.__name__,
            "duration": end_time - start_time,
            "timestamp": time.time()
        })
        
        # Keep only last 50 timings
        if len(st.session_state["performance_timings"]) > 50:
            st.session_state["performance_timings"] = st.session_state["performance_timings"][-50:]
        
        return result
    return wrapper
```

**Database Index Migration** [Source: docs/architecture/data-architecture.md#Performance Optimization]:
```sql
-- Performance indexes migration
-- File: scripts/migrate_performance_indexes.sql

-- Index for bets table filtering
CREATE INDEX IF NOT EXISTS idx_bets_status_created 
ON bets(status, created_at_utc DESC);

-- Index for surebets table filtering  
CREATE INDEX IF NOT EXISTS idx_surebets_status_created 
ON surebets(status, created_at_utc DESC);

-- Index for ledger entries by surebet
CREATE INDEX IF NOT EXISTS idx_ledger_surebet 
ON ledger_entries(surebet_id, created_at_utc DESC);

-- Index for ledger entries by creation time
CREATE INDEX IF NOT EXISTS idx_ledger_created 
ON ledger_entries(created_at_utc DESC);

-- Verify index usage
EXPLAIN QUERY PLAN 
SELECT * FROM bets 
WHERE status = 'incoming' 
ORDER BY created_at_utc DESC 
LIMIT 25;

EXPLAIN QUERY PLAN 
SELECT * FROM surebets 
WHERE status = 'open' 
ORDER BY created_at_utc DESC 
LIMIT 25;
```

**Performance Dashboard** [Source: docs/architecture/frontend-architecture.md#Diagnostics Hygiene]:
```python
# src/ui/pages/7_admin_associates.py (enhanced with performance)
def render_performance_dashboard():
    """Comprehensive performance monitoring dashboard"""
    with st.expander("âš¡ Performance Dashboard", expanded=False):
        
        # Performance metrics
        timings = st.session_state.get("performance_timings", [])
        
        if timings:
            st.subheader("Recent Page Load Times")
            
            # Create performance dataframe
            perf_df = pd.DataFrame(timings)
            perf_df['timestamp_formatted'] = pd.to_datetime(perf_df['timestamp'], unit='s').dt.strftime('%H:%M:%S')
            
            # Show last 50 timings
            recent_df = perf_df.tail(50)[['timestamp_formatted', 'function', 'duration']]
            recent_df.columns = ['Time', 'Page/Function', 'Duration (s)']
            
            st.dataframe(
                recent_df,
                column_config={
                    "Duration (s)": st.column_config.NumberColumn(
                        "Duration", 
                        format="%.3f",
                        help="Page load time in seconds"
                    )
                },
                hide_index=True,
                width="stretch"
            )
            
            # Performance summary
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Avg Load Time", f"{perf_df['duration'].mean():.3f}s")
            with col2:
                st.metric("Max Load Time", f"{perf_df['duration'].max():.3f}s")
            with col3:
                st.metric("Min Load Time", f"{perf_df['duration'].min():.3f}s")
        
        # System performance
        st.subheader("System Performance")
        col1, col2 = st.columns(2)
        
        with col1:
            # Database performance
            with st.expander("Database Performance"):
                # Index usage statistics
                # Query performance metrics
                # Connection pool status
                st.write("ðŸ“Š Database metrics coming soon")
        
        with col2:
            # Cache performance
            with st.expander("Cache Performance"):
                # Cache hit rates
                # Cache memory usage
                # Cache invalidation count
                st.write("ðŸ’¾ Cache metrics coming soon")
        
        # Performance Playbook link
        st.subheader("Performance Guidelines")
        st.markdown("""
        **UI Performance Playbook** ðŸ“–
        - Target page load times: < 2 seconds
        - Target filter response: < 1.5 seconds  
        - Cache hit rate target: > 80%
        - Index usage target: > 95% for filtered queries
        
        See `docs/performance-playbook.md` for detailed optimization guidelines.
        """)
```

### Testing Requirements

**Testing Standards** [Source: docs/architecture/testing-strategy.md#L34-L41]:
- Use pytest 7.0+ as testing framework
- Test file naming: `test_` prefix
- Test function naming: descriptive names
- Follow AAA pattern (Arrange, Act, Assert)

**Performance Testing Requirements** [Source: docs/architecture/testing-strategy.md#L482-L492]:
- Unit tests for caching and pagination logic: 90%+ coverage
- Integration tests for performance optimizations: 80%+ coverage
- Benchmark tests for 10k dataset scenarios
- Performance regression tests in CI/CD pipeline

**Test Structure** [Source: docs/architecture/testing-strategy.md#L54-L77]:
```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ test_cache.py                    # Caching system tests
â”‚   â”œâ”€â”€ test_pagination.py                # Pagination logic tests
â”‚   â”œâ”€â”€ test_media.py                    # Thumbnail generation tests
â”‚   â”œâ”€â”€ test_performance_helpers.py       # Rerun guardrails tests
â”‚   â””â”€â”€ test_database_indexes.py         # Index migration tests
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ test_performance_integration.py   # End-to-end performance tests
â”‚   â””â”€â”€ test_benchmark_scenarios.py     # Large dataset benchmarks
â””â”€â”€ performance/
    â”œâ”€â”€ benchmark_10k_bets.py           # 10k bet performance test
    â””â”€â”€ performance_regression.py       # Performance regression suite
```

**Example Performance Tests**:
```python
# tests/unit/test_cache.py
def test_query_df_caching():
    """Test that query_df properly caches results"""
    # Mock database query
    # Verify cache hit/miss behavior
    # Test TTL expiration
    pass

def test_cache_invalidation():
    """Test cache invalidation on write operations"""
    # Test cache clearing after writes
    # Verify fresh data after invalidation
    pass

# tests/unit/test_pagination.py
def test_pagination_offset_calculation():
    """Test pagination offset and limit calculations"""
    # Test various page sizes and page numbers
    # Test edge cases (first/last page)
    pass

# tests/performance/benchmark_10k_bets.py
def test_10k_bet_filter_performance():
    """Benchmark: 10k bets â†’ filter apply â‰¤ 1.5s"""
    # Create 10k test bets
    # Measure filter application time
    # Assert performance targets met
    pass
```

### File Structure Requirements

**New Performance Files** [Source: docs/architecture/source-tree.md#src/ui/]:
```
src/ui/
â”œâ”€â”€ cache.py                           # NEW: Centralized caching system
â”œâ”€â”€ media.py                           # NEW: Thumbnail and media handling
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ pagination.py                   # NEW: Pagination helpers
â”‚   â””â”€â”€ state_management.py            # ENHANCED: Rerun guardrails
â””â”€â”€ pages/
    â”œâ”€â”€ 1_incoming_bets.py              # UPDATED: Pagination + caching
    â”œâ”€â”€ 2_surebets.py                 # UPDATED: Pagination + caching
    â”œâ”€â”€ 3_settlement.py                # UPDATED: Pagination + caching
    â”œâ”€â”€ 4_reconciliation.py            # UPDATED: Pagination + caching
    â”œâ”€â”€ 5_export.py                    # UPDATED: Pagination + caching
    â”œâ”€â”€ 6_statements.py                # UPDATED: Pagination + caching
    â””â”€â”€ 7_admin_associates.py         # UPDATED: Performance dashboard
```

**Database Migration Files** [Source: docs/architecture/source-tree.md#scripts/]:
```
scripts/
â”œâ”€â”€ migrate_performance_indexes.sql      # NEW: Performance indexes migration
â””â”€â”€ benchmark_10k_data.py             # NEW: Performance test data generator
```

**Updated Dependencies** [Source: docs/architecture/source-tree.md#requirements.txt]:
```
Pillow>=10.0.0                        # EXISTING: For thumbnail generation
streamlit>=1.30.0                     # EXISTING: For caching features
```

### Technical Constraints

**Performance Targets** [Source: docs/architecture/frontend-architecture.md#Performance & Reliability]:
- Page load times: < 2 seconds for all pages
- Filter response times: < 1.5 seconds for 10k dataset
- Cache hit rates: > 80% for repeated queries
- Database query performance: < 100ms for indexed queries

**Caching Constraints**:
- Use `@st.cache_resource` for DB connections and long-lived resources
- Use `@st.cache_data(ttl=300)` for query results (5-minute TTL)
- Invalidate cache on write operations to maintain data consistency
- Monitor cache hit rates and optimize accordingly

**Pagination Constraints**:
- Default page size: 25 rows with options for 50, 100
- Maintain filter state across page navigation
- Preserve sorting preferences when changing pages
- Use parameterized queries for security and performance

**Thumbnail Constraints**:
- Maximum thumbnail width: 300px (configurable)
- Maintain aspect ratio when generating thumbnails
- Cache thumbnails for 1 hour to balance performance and freshness
- Handle image generation errors gracefully

**Database Constraints**:
- All new indexes must use `IF NOT EXISTS` for safe migration
- Verify index usage with `EXPLAIN QUERY PLAN`
- Monitor index impact on write performance
- Document index purpose and expected query patterns

### Import Dependencies

**Standard Library Imports**:
```python
import os
import io
import time
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path
from functools import wraps
```

**Third-party Libraries**:
```python
import streamlit as st
import pandas as pd
from PIL import Image
import sqlite3
```

**Local Imports**:
```python
from src.core.database import get_db_connection
from src.ui.utils.state_management import safe_rerun
from src.ui.utils.formatters import format_utc_datetime
from src.ui.utils.feature_flags import has
```

## Testing

### Testing Standards

**Test Framework** [Source: docs/architecture/testing-strategy.md#L34-L41]:
- Use pytest 7.0+ as testing framework
- Test file naming: `test_` prefix
- Test function naming: descriptive names
- Follow AAA pattern (Arrange, Act, Assert)

**Test Structure** [Source: docs/architecture/testing-strategy.md#L54-L77]:
```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ test_cache.py                    # Unit tests for caching system
â”‚   â”œâ”€â”€ test_pagination.py                # Unit tests for pagination logic
â”‚   â”œâ”€â”€ test_media.py                    # Unit tests for thumbnail generation
â”‚   â”œâ”€â”€ test_performance_helpers.py       # Unit tests for rerun guardrails
â”‚   â””â”€â”€ test_database_indexes.py         # Unit tests for index migration
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ test_performance_integration.py   # Integration tests for performance optimizations
â”‚   â”œâ”€â”€ test_benchmark_scenarios.py     # Integration tests for large datasets
â”‚   â””â”€â”€ test_performance_dashboard.py    # Tests for performance monitoring
â”œâ”€â”€ performance/
â”‚   â”œâ”€â”€ benchmark_10k_bets.py           # Performance benchmark for 10k dataset
â”‚   â””â”€â”€ performance_regression.py       # Performance regression test suite
â””â”€â”€ fixtures/
    â”œâ”€â”€ performance_test_data.sql         # Test data for performance scenarios
    â””â”€â”€ sample_screenshots/             # Sample images for thumbnail testing
```

**Performance Testing Approach**:
1. **Unit tests** for caching, pagination, and helper functions (90%+ coverage)
2. **Integration tests** for performance optimizations across pages (80%+ coverage)
3. **Benchmark tests** for large dataset scenarios (10k+ records)
4. **Performance regression tests** to prevent slowdowns over time

**Example Unit Tests**:
```python
# tests/unit/test_cache.py
def test_query_df_caching_behavior():
    """Test that query_df properly caches and reuses results"""
    # Mock database and test cache hit/miss
    pass

def test_cache_ttl_expiration():
    """Test cache TTL expiration behavior"""
    # Test that cache expires after TTL
    pass

# tests/unit/test_pagination.py
def test_pagination_offset_calculation():
    """Test pagination calculations for various scenarios"""
    # Test edge cases: first page, last page, empty results
    pass

def test_pagination_state_management():
    """Test pagination state preservation across interactions"""
    pass

# tests/unit/test_media.py
def test_thumbnail_generation():
    """Test thumbnail generation with various image formats"""
    # Test PNG, JPEG, and error handling
    pass

def test_thumbnail_caching():
    """Test thumbnail caching behavior"""
    pass
```

**Example Integration Tests**:
```python
# tests/integration/test_performance_integration.py
def test_paginated_table_performance():
    """Test that paginated tables load quickly"""
    # Create 10k test records
    # Measure page load time with pagination
    # Assert performance targets met
    pass

def test_cached_filter_performance():
    """Test that cached filters improve performance"""
    # Measure filter time with and without cache
    # Verify cache hit rates
    pass
```

**Benchmark Tests**:
```python
# tests/performance/benchmark_10k_bets.py
def test_10k_bet_filter_performance():
    """Benchmark: Filter 10k bets in â‰¤ 1.5 seconds"""
    # Generate 10k test bets
    # Apply various filters and measure time
    # Assert performance targets met
    pass

def test_10k_bet_pagination_performance():
    """Benchmark: Paginate 10k bets in â‰¤ 0.5 seconds"""
    # Test pagination performance
    pass
```

**Manual Testing Checklist**:
- [ ] Pagination controls work correctly on all table pages
- [ ] Page size changes (25/50/100) work properly
- [ ] Filter application times meet performance targets (â‰¤ 1.5s for 10k records)
- [ ] Thumbnails generate correctly for all image formats
- [ ] Thumbnail click-to-expand functionality works
- [ ] Cache invalidation works after data modifications
- [ ] Performance dashboard shows accurate timing data
- [ ] Database indexes are used (verified with EXPLAIN)
- [ ] Form-gated filters prevent unnecessary reruns
- [ ] Rerun guardrails prevent excessive page refreshes
- [ ] Hot paths are optimized (no unnecessary sleeps or logs)
- [ ] 10k dataset benchmarks meet performance targets
- [ ] Performance regression tests pass

**Coverage Target** [Source: docs/architecture/testing-strategy.md#L482-L492]:
- Unit tests for caching and pagination: 90%+
- Integration tests for performance features: 80%+
- Benchmark test coverage: All major performance scenarios

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-07 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be populated by Dev Agent]

### Debug Log References
[To be populated by Dev Agent]

### Completion Notes List
[To be populated by Dev Agent]

### File List
[To be populated by Dev Agent]

## QA Results

### Review Date: [To be populated by QA Agent]

### Reviewed By: [To be populated by QA Agent]

### Code Quality Assessment
[To be populated by QA Agent]

### Refactoring Performed
[To be populated by QA Agent]

### Compliance Check
[To be populated by QA Agent]

### Improvements Checklist
[To be populated by QA Agent]

### Security Review
[To be populated by QA Agent]

### Performance Considerations
[To be populated by QA Agent]

### Files Modified During Review
[To be populated by QA Agent]

### Requirements Traceability
[To be populated by QA Agent]

### Testing Coverage Analysis
[To be populated by QA Agent]

### Risk Assessment
[To be populated by QA Agent]

### Gate Status
[To be populated by QA Agent]

### Recommended Status
[To be populated by QA Agent]

### Technical Debt Assessment
[To be populated by QA Agent]

### Quality Score
[To be populated by QA Agent]
