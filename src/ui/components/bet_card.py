"""Bet card component for displaying incoming bets."""

import streamlit as st
from typing import Dict, Any, Optional, List
from pathlib import Path
from decimal import Decimal
from html import escape
from src.services.matching_service import MatchingSuggestions, EventSuggestion, MarketSuggestion
from src.ui.utils.formatters import (
    format_timestamp_relative,
    format_confidence_badge,
    format_bet_summary,
    format_market_display,
)
from src.ui.helpers.dialogs import (
    open_dialog,
    render_canonical_event_dialog,
)
from src.ui.helpers.streaming import show_pdf_preview
from src.ui.media import render_thumbnail
from src.ui.utils.state_management import safe_rerun

DEFAULT_THUMB_WIDTH = 180
COMPACT_THUMB_WIDTH = 135
DEFAULT_COLUMN_WEIGHTS = [1, 3, 1]
COMPACT_COLUMN_WEIGHTS = [0.85, 3.5, 1.1]

def render_bet_card(
    bet: Dict[str, Any],
    show_actions: bool = True,
    editable: bool = True,
    verification_service=None,
    matching_suggestions: Optional[MatchingSuggestions] = None,
    compact_mode: bool = False,
) -> None:
    """Render a single bet card with screenshot preview and details.

    Args:
        bet: Dictionary containing bet data (from database query)
        show_actions: Whether to show approve/reject buttons
        editable: Whether to show inline edit fields
        verification_service: BetVerificationService instance for data loading
        matching_suggestions: Optional suggestions generated by MatchingService
        compact_mode: Whether to use compact suggestion display
    """
    bet_id = bet.get("bet_id", bet.get("id"))
    dialog_key = f"create_event_{bet_id}"

    auto_payload = (
        matching_suggestions.best_auto_payload(bet)
        if matching_suggestions
        else None
    )

    if st.session_state.pop(f"show_create_event_modal_{bet_id}", False):
        open_dialog(dialog_key)

    if verification_service is not None:
        payload = render_canonical_event_dialog(key=dialog_key, bet=bet)
        if payload:
            try:
                event_id = verification_service._create_canonical_event(
                    event_name=payload["event_name"],
                    sport=payload["sport"],
                    competition=payload["competition"],
                    kickoff_time_utc=payload["kickoff_time_utc"],
                )
                st.success(f"âœ… Event created: {payload['event_name']}")
                st.session_state["newly_created_event_id"] = event_id
                safe_rerun()
            except ValueError as error:
                st.error(f"Validation error: {error}")
                open_dialog(dialog_key)
            except Exception as error:
                st.error(f"Failed to create event: {error}")
                open_dialog(dialog_key)

    column_weights = (
        COMPACT_COLUMN_WEIGHTS if compact_mode else DEFAULT_COLUMN_WEIGHTS
    )
    thumb_width = COMPACT_THUMB_WIDTH if compact_mode else DEFAULT_THUMB_WIDTH

    with st.container():
        # Create 3-column layout: screenshot | details | actions
        col1, col2, col3 = st.columns(column_weights)

        with col1:
            # Screenshot preview
            _render_screenshot_preview(bet, thumb_width=thumb_width)

        with col2:
            # Bet details (editable or read-only)
            if editable and verification_service:
                _render_bet_details_editable(
                    bet,
                    verification_service,
                    matching_suggestions,
                    compact_mode=compact_mode,
                )
            else:
                _render_bet_details(
                    bet, matching_suggestions, compact_mode=compact_mode
                )

        with col3:
            # Confidence badge and actions
            _render_bet_actions(
                bet,
                show_actions,
                editable,
                auto_payload=auto_payload,
                matching_suggestions=matching_suggestions,
            )

        _render_card_divider(compact_mode)


def _render_bet_title(bet: Dict[str, Any]) -> None:
    """Render the bet title with emphasized styling."""
    bet_id = bet.get("bet_id") or bet.get("id") or "?"
    associate = bet.get("associate") or "Associate"
    bookmaker = bet.get("bookmaker") or "Bookmaker"

    st.markdown(
        "".join(
            [
                "<div class='bet-card__title'>",
                f"<span class='bet-card__title-id'>Bet #{escape(str(bet_id))}</span>",
                f"<span class='bet-card__title-meta'>{escape(str(associate))} @ {escape(str(bookmaker))}</span>",
                "</div>",
            ]
        ),
        unsafe_allow_html=True,
    )


def _render_card_divider(compact_mode: bool) -> None:
    if compact_mode:
        st.markdown(
            "<hr style='margin:0.25rem 0;border-top:1px dashed rgba(148,163,184,0.35);' />",
            unsafe_allow_html=True,
        )
    else:
        st.markdown("---")


def _render_screenshot_preview(bet: Dict[str, Any], *, thumb_width: int) -> None:
    """Render screenshot or PDF slip preview."""
    screenshot_path = bet.get("screenshot_path")

    if not screenshot_path:
        st.warning("Screenshot\nnot found")
        return

    file_path = Path(screenshot_path)
    if not file_path.exists():
        st.warning("Screenshot\nnot found")
        return

    if file_path.suffix.lower() == ".pdf":
        st.caption(":material/picture_as_pdf: Slip Preview")
        show_pdf_preview(str(file_path), height=420)
        return

    render_thumbnail(
        file_path,
        caption="Bet slip preview",
        width=thumb_width,
        expander_label=":material/zoom_in: View full resolution",
    )


def _render_bet_details(
    bet: Dict[str, Any],
    matching_suggestions: Optional[MatchingSuggestions],
    *,
    compact_mode: bool = False,
) -> None:
    """Render bet details section."""
    _render_bet_title(bet)

    source_label = (
        "Telegram" if bet.get("ingestion_source") == "telegram" else "Manual Upload"
    )
    timestamp_rel = format_timestamp_relative(bet["created_at_utc"])
    st.caption(f"{source_label} - {timestamp_rel}")

    if bet.get("canonical_event"):
        st.write(f"**Event:** {bet['canonical_event']}")
        st.write(f"**Market:** {format_market_display(bet.get('market_code'))}")

        details = []
        if bet.get("period_scope"):
            details.append(bet["period_scope"].replace("_", " ").title())
        if bet.get("line_value"):
            details.append(f"Line: {bet['line_value']}")
        if bet.get("side"):
            details.append(f"Side: {bet['side']}")
        if details:
            st.caption(" - ".join(details))

        bet_summary = format_bet_summary(
            bet.get("stake"),
            bet.get("odds"),
            bet.get("payout"),
            bet.get("currency", "AUD"),
        )
        st.write(f"**Bet:** {bet_summary}")

        if bet.get("kickoff_time_utc"):
            st.caption(f"Kickoff: {bet['kickoff_time_utc']}")
    else:
        st.warning("Extraction failed - manual entry required")

    if bet.get("is_multi"):
        st.error("Accumulator bet detected - manual handling required")

    if bet.get("operator_note"):
        st.info(f"Note: {bet['operator_note']}")

    if matching_suggestions:
        _render_matching_suggestions(
            matching_suggestions, compact_mode=compact_mode
        )


def _render_bet_details_editable(
    bet: Dict[str, Any],
    verification_service,
    matching_suggestions: Optional[MatchingSuggestions],
    compact_mode: bool = False,
) -> None:
    """Render bet details with inline editing fields."""
    bet_id = bet["bet_id"]

    _render_bet_title(bet)

    source_label = (
        "Telegram" if bet.get("ingestion_source") == "telegram" else "Manual Upload"
    )
    timestamp_rel = format_timestamp_relative(bet["created_at_utc"])
    st.caption(f"{source_label} - {timestamp_rel}")

    # Load canonical data once
    canonical_events = verification_service.load_canonical_events()
    canonical_markets = verification_service.load_canonical_markets()

    # Event search/filter to keep long lists manageable.
    # Kept outside the form so pressing Enter here does NOT submit/approve.
    search_col, _ = st.columns([2, 1])
    with search_col:
        event_search = st.text_input(
            "Search events",
            key=f"event_search_{bet_id}",
            placeholder="Type team names or league...",
        )

    filtered_events = canonical_events
    if event_search:
        query = event_search.lower().strip()
        if query:
            filtered_events = [
                e
                for e in canonical_events
                if query in (e.get("normalized_event_name") or "").lower()
                or query in (e.get("league") or "").lower()
            ]

    with st.form(key=f"edit_bet_{bet_id}"):

        # Ensure currently selected event stays in the list even if filtered out
        current_event_idx = 0
        current_event_id = bet.get("canonical_event_id")
        if current_event_id:
            current_event = next(
                (e for e in canonical_events if e.get("id") == current_event_id),
                None,
            )
            if current_event and not any(
                e.get("id") == current_event_id for e in filtered_events
            ):
                filtered_events = [current_event] + filtered_events

        event_options = ["(None - Select Event)"] + [
            f"{e['normalized_event_name']} ({e['kickoff_time_utc'][:10] if e['kickoff_time_utc'] else 'TBD'})"
            for e in filtered_events
        ]
        event_options.append("[+] Create New Event")

        if current_event_id:
            for i, event in enumerate(filtered_events):
                if event.get("id") == current_event_id:
                    current_event_idx = i + 1
                    break

        event_col, manual_col = st.columns([2, 1])
        with event_col:
            selected_event = st.selectbox("Event", event_options, index=current_event_idx)

        manual_event_name_default = bet.get("selection_text") or ""
        manual_event_name = manual_event_name_default

        if selected_event == "[+] Create New Event":
            with manual_col:
                open_clicked = st.form_submit_button(
                    "Open Event Creator", width="stretch"
                )
            if open_clicked:
                st.session_state[f"show_create_event_modal_{bet_id}"] = True
                safe_rerun()
            return
        else:
            with manual_col:
                manual_event_name = st.text_input(
                    "Event Name (auto-create)",
                    value=manual_event_name_default,
                    placeholder="e.g., Manchester United vs Liverpool",
                    help="Used if you approve without selecting an existing event.",
                    key=f"event_name_input_{bet_id}",
                )

        market_options = ["(None - Select Market)"] + [
            f"{m['description']} ({m['market_code']})" for m in canonical_markets
        ]

        current_market_idx = 0
        if bet.get("market_code"):
            for i, market in enumerate(canonical_markets):
                if market["market_code"] == bet["market_code"]:
                    current_market_idx = i + 1
                    break

        selected_market = st.selectbox(
            "Market", market_options, index=current_market_idx
        )
        market_code = None
        if selected_market != "(None - Select Market)":
            market_code = selected_market.split("(")[-1].rstrip(")")
        valid_sides = verification_service.get_valid_sides_for_market(market_code)
        current_side = bet.get("side", valid_sides[0] if valid_sides else "OVER")
        side_idx = valid_sides.index(current_side) if current_side in valid_sides else 0
        side = st.selectbox("Side", valid_sides, index=side_idx)

        period_options = [
            "FULL_MATCH",
            "FIRST_HALF",
            "SECOND_HALF",
            "FIRST_QUARTER",
            "SECOND_QUARTER",
        ]
        current_period = bet.get("period_scope", "FULL_MATCH")
        selected_period = st.selectbox(
            "Period",
            period_options,
            index=(
                period_options.index(current_period)
                if current_period in period_options
                else 0
            ),
        )
        current_line = float(bet["line_value"]) if bet.get("line_value") else 0.0
        line_value = st.number_input(
            "Line Value (optional)", value=current_line, step=0.5, format="%.1f"
        )

        col_stake, col_odds, col_payout = st.columns(3)

        with col_stake:
            stake_value = bet.get("stake")
            current_stake = float(stake_value) if stake_value else 1.0
            stake = st.number_input(
                "Stake", value=current_stake, min_value=0.01, step=1.0
            )

        with col_odds:
            odds_value = bet.get("odds")
            current_odds = float(odds_value) if odds_value else 1.5
            odds = st.number_input(
                "Odds", value=current_odds, min_value=1.0, step=0.01, format="%.2f"
            )

        with col_payout:
            payout = stake * odds
            st.number_input(
                "Payout (auto)", value=payout, disabled=True, format="%.2f"
            )

        currency_options = ["AUD", "GBP", "EUR", "USD", "NZD", "CAD"]
        current_currency = bet.get("currency", "AUD")
        currency_idx = (
            currency_options.index(current_currency)
            if current_currency in currency_options
            else 0
        )
        currency = st.selectbox("Currency", currency_options, index=currency_idx)

        if bet.get("is_multi"):
            st.warning("Accumulator bet detected - manual handling required")

        if bet.get("operator_note"):
            st.info(f"Note: {bet['operator_note']}")

        col_approve, col_reject = st.columns(2)
        with col_approve:
            approve_submitted = st.form_submit_button(
                "Approve", type="primary", width="stretch"
            )
        with col_reject:
            reject_submitted = st.form_submit_button(
                "Reject", width="stretch"
            )

    if matching_suggestions:
        _render_matching_suggestions(matching_suggestions, compact_mode=compact_mode)

    # Handle form submission
    if approve_submitted:
        st.session_state[f"approve_bet_{bet_id}"] = {
            "event_selection": selected_event,
            "canonical_events": canonical_events,
            "market_selection": selected_market,
            "canonical_markets": canonical_markets,
            "period": selected_period,
            "line": line_value,
            "side": side,
            "stake": stake,
            "odds": odds,
            "payout": payout,
            "currency": currency,
            "event_name_input": manual_event_name,
        }
        safe_rerun()

    if reject_submitted:
        st.session_state[f"reject_bet_{bet_id}"] = True
        safe_rerun()


def _render_bet_actions(
    bet: Dict[str, Any],
    show_actions: bool,
    editable: bool = False,
    auto_payload: Optional[Dict[str, Any]] = None,
    matching_suggestions: Optional[MatchingSuggestions] = None,
) -> None:
    """Render confidence badge, suggestions, and action buttons."""
    bet_id = bet.get("bet_id", bet.get("id"))
    _render_confidence_rationale_badge(bet_id, bet.get("normalization_confidence"))

    if auto_payload and matching_suggestions:
        top_event = next(iter(matching_suggestions.events), None)
        top_market = next(iter(matching_suggestions.markets), None)
        if top_event:
            st.caption(f"Suggested event: {top_event.name}")
        if top_market:
            st.caption(
                f"Suggested market: {top_market.market_code} ({top_market.description})"
            )
        if st.button(
            "Approve Suggested",
            key=f"auto_approve_{bet_id}",
            type="primary",
            width="stretch",
        ):
            st.session_state[f"approve_bet_{bet_id}"] = auto_payload
            safe_rerun()
        st.markdown("---")

    if show_actions and not editable:
        if st.button(
            "Approve",
            key=f"approve_{bet_id}",
            type="primary",
            width="stretch",
        ):
            st.session_state[f"approve_bet_{bet_id}"] = True
            safe_rerun()

        if st.button(
            "Reject",
            key=f"reject_{bet_id}",
            width="stretch",
        ):
            st.session_state[f"reject_bet_{bet_id}"] = True
            safe_rerun()


def _render_confidence_rationale_badge(
    bet_id: Any, confidence: Optional[float]
) -> None:
    """Render a focusable badge with synchronized tooltip rationale."""
    emoji, label, color, tooltip = format_confidence_badge(confidence)
    tooltip_id = f"confidence-tooltip-{bet_id}"
    sr_id = f"{tooltip_id}-sr"

    try:
        numeric_confidence = (
            None if confidence is None else float(confidence)  # type: ignore[arg-type]
        )
    except (TypeError, ValueError):
        numeric_confidence = None

    confidence_attr = "" if numeric_confidence is None else f"{numeric_confidence:.4f}"

    html = f"""
    <div class="confidence-badge-wrapper" data-variant="{escape(color)}">
        <button
            class="confidence-badge-button"
            type="button"
            aria-describedby="{escape(sr_id)}"
            title="{escape(tooltip, quote=True)}"
            data-variant="{escape(color)}"
            data-confidence="{escape(confidence_attr)}"
        >
            <span class="confidence-badge-emoji">{escape(emoji)}</span>
            <span class="confidence-badge-label">{escape(label)}</span>
        </button>
        <div id="{escape(tooltip_id)}" class="confidence-tooltip" role="tooltip">
            <p class="confidence-tooltip-text">{escape(tooltip)}</p>
        </div>
        <span id="{escape(sr_id)}" class="sr-only" aria-live="polite">
            {escape(tooltip)}
        </span>
    </div>
    """

    st.markdown(html, unsafe_allow_html=True)


def _render_matching_suggestions(
    suggestions: MatchingSuggestions, max_items: int = 3, compact_mode: bool = False
) -> None:
    """Display event and market suggestions."""
    if not suggestions:
        return

    has_events = bool(suggestions.events)
    has_markets = bool(suggestions.markets)
    if not has_events and not has_markets:
        return

    if compact_mode:
        _render_compact_suggestions(suggestions, compact_mode=True)
    else:
        st.markdown("**Matching Suggestions**")
        
        if has_events:
            st.caption("Events")
            for suggestion in suggestions.events[:max_items]:
                _render_event_suggestion(suggestion)

        if has_markets:
            st.caption("Markets")
            for suggestion in suggestions.markets[:max_items]:
                _render_market_suggestion(suggestion)


def _render_suggestion_chip(label: str, help_text: str = "") -> None:
    """Render a tiny suggestion chip."""
    st.markdown(
        f"""
        <span class="sb-chip" title="{help_text}">
          {label}
        </span>
        """,
        unsafe_allow_html=True,
    )


def _render_collapsible_suggestion(
    title: str,
    chips: List[str],
    body_lines: List[str],
    *,
    variant: str = "info",
    default_open: bool = False,
) -> None:
    """Render a compact accordion for a suggestion."""
    sanitized_chips = "".join(
        f'<span class="sb-chip">{escape(chip)}</span>' for chip in chips if chip
    )
    detail_rows = "".join(
        f"<div class='suggestion-detail-row'>{line}</div>" for line in body_lines if line
    )
    if not detail_rows:
        detail_rows = "<div class='suggestion-detail-row muted'>No additional details</div>"
    open_attr = " open" if default_open else ""
    st.markdown(
        f"""
        <details class="suggestion-accordion" data-variant="{variant}"{open_attr}>
            <summary>
                <span class="suggestion-title">{escape(title)}</span>
                <span class="suggestion-meta">{sanitized_chips}</span>
            </summary>
            <div class="suggestion-body">
                {detail_rows}
            </div>
        </details>
        """,
        unsafe_allow_html=True,
    )


def _format_detail_row(label: str, value: Optional[str]) -> Optional[str]:
    """Format a labeled detail row."""
    if value is None or value == "":
        return None
    return (
        f"<span class='detail-label'>{escape(label)}</span>"
        f"<span class='detail-value'>{escape(str(value))}</span>"
    )


def _render_compact_suggestions(suggestions: MatchingSuggestions, compact_mode: bool = True) -> None:
    """Render suggestions in compact format."""
    if not suggestions:
        return

    evts = suggestions.events
    mkts = suggestions.markets

    if compact_mode:
        # side-by-side, one line each
        c1, c2 = st.columns([1, 1])
        with c1:
            _render_compact_suggestion_section(evts, "Events")
        with c2:
            _render_compact_suggestion_section(mkts, "Markets")
    else:
        # current verbose layout -> move into expanders to save space
        c1, c2 = st.columns([1, 1])
        with c1:
            with st.expander("Events", expanded=False):
                for e in evts:
                    st.write(
                        f"**{e.name}**  \n"
                        f"Match: {e.similarity:.0f}% | {e.reason}"
                    )
        with c2:
            with st.expander("Markets", expanded=False):
                for m in mkts:
                    st.write(
                        f"**{m.market_code}** ({m.description})  \n"
                        f"Match: {m.score:.0f}% | {m.reason}"
                    )


def _render_compact_suggestion_section(suggestions, section_label: str) -> None:
    """Render a single section of suggestions in compact format."""
    # suggestions.events or suggestions.markets (already ranked best-first)
    best = suggestions[0] if suggestions else None
    rest_count = max(0, len(suggestions) - 1)

    cols = st.columns([1, 5, 1])
    with cols[0]:
        st.caption(section_label)
    with cols[1]:
        if section_label == "Events" and best:
            _render_suggestion_chip(
                f"{best.name}",
                f"Match: {best.similarity:.0f}% • {best.reason}",
            )
        elif section_label == "Markets" and best:
            _render_suggestion_chip(
                f"{best.description}",
                f"Match: {best.score:.0f}% • {best.reason}",
            )
    with cols[2]:
        if rest_count > 0:
            if hasattr(st, 'popover'):
                # Use popover
                with st.popover(f"+{rest_count} more"):
                    # ultra-compact list of the remaining items
                    for item in (suggestions[1:]):
                        if section_label == "Events":
                            st.caption(
                                f"• {item.name}  ·  {item.similarity:.0f}%  ·  {item.reason}"
                            )
                        else:
                            st.caption(
                                f"• {item.description}  ·  {item.score:.0f}%  ·  {item.reason}"
                            )
            else:
                # Use expander fallback
                with st.expander(f"+{rest_count} more", expanded=False):
                    for item in (suggestions[1:]):
                        if section_label == "Events":
                            st.caption(
                                f"• {item.name}  ·  {item.similarity:.0f}%  ·  {item.reason}"
                            )
                        else:
                            st.caption(
                                f"• {item.description}  ·  {item.score:.0f}%  ·  {item.reason}"
                            )


def _render_event_suggestion(suggestion: EventSuggestion) -> None:
    """Render a single event suggestion."""
    chips = [f"Match {suggestion.similarity:.0f}%"]
    if suggestion.pair_key_match:
        chips.append("Pair key")
    if suggestion.hours_apart is not None:
        chips.append(f"Delta {suggestion.hours_apart:.1f}h")

    detail_lines: List[str] = []
    reason_detail = _format_detail_row("Reason", suggestion.reason)
    if reason_detail:
        detail_lines.append(reason_detail)
    pair_detail = _format_detail_row(
        "Pair key", "Match" if suggestion.pair_key_match else "Mismatch"
    )
    if pair_detail:
        detail_lines.append(pair_detail)
    if suggestion.hours_apart is not None:
        delta_detail = _format_detail_row(
            "Time delta", f"{suggestion.hours_apart:.1f}h"
        )
        if delta_detail:
            detail_lines.append(delta_detail)
    kickoff_detail = _format_detail_row("Kickoff", suggestion.kickoff_time_utc)
    if kickoff_detail:
        detail_lines.append(kickoff_detail)

    _render_collapsible_suggestion(
        title=suggestion.name,
        chips=chips,
        body_lines=detail_lines,
        variant="success" if suggestion.is_high_confidence else "info",
    )


def _render_market_suggestion(suggestion: MarketSuggestion) -> None:
    """Render a single market suggestion."""
    def _format_period(period: Optional[str]) -> Optional[str]:
        if not period:
            return None
        return period.replace("_", " ").title()

    chips = [f"Match {suggestion.score:.0f}%"]
    period_label = _format_period(suggestion.period_scope)
    if period_label:
        chips.append(period_label)
    if suggestion.line_value:
        chips.append(f"Line {suggestion.line_value}")
    if suggestion.side:
        chips.append(suggestion.side)

    detail_lines: List[str] = []
    code_detail = _format_detail_row("Code", suggestion.market_code)
    if code_detail:
        detail_lines.append(code_detail)
    if suggestion.period_scope:
        period_detail = _format_detail_row("Period", period_label)
        if period_detail:
            detail_lines.append(period_detail)
    if suggestion.line_value:
        line_detail = _format_detail_row("Line", str(suggestion.line_value))
        if line_detail:
            detail_lines.append(line_detail)
    if suggestion.side:
        side_detail = _format_detail_row("Side", suggestion.side)
        if side_detail:
            detail_lines.append(side_detail)
    reason_detail = _format_detail_row("Reason", suggestion.reason)
    if reason_detail:
        detail_lines.append(reason_detail)

    _render_collapsible_suggestion(
        title=suggestion.description or suggestion.market_code,
        chips=chips,
        body_lines=detail_lines,
        variant="success" if suggestion.is_high_confidence else "info",
    )
